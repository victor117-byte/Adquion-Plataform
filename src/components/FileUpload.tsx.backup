import { useState, useCallback } from 'react';
import { Upload, File, X, CheckCircle, AlertCircle } from 'lucide-react';
import { Card } from './ui/card';
import { Button } from './ui/button';
import { Progress } from './ui/progress';
import { toast } from '@/hooks/use-toast';

interface FileWithProgress {
  file: File;
  progress: number;
  status: 'pending' | 'uploading' | 'success' | 'error';
  error?: string;
}

export const FileUpload = () => {
  const [files, setFiles] = useState<FileWithProgress[]>([]);
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);

  const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api';

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setIsDragging(true);
    } else if (e.type === "dragleave") {
      setIsDragging(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const droppedFiles = Array.from(e.dataTransfer.files);
    addFiles(droppedFiles);
  }, []);

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    console.log('üéØ handleFileInput llamado');
    
    if (e.target.files && e.target.files.length > 0) {
      const selectedFiles = Array.from(e.target.files);
      console.log('üìÇ Archivos seleccionados:', selectedFiles.map(f => f.name));
      addFiles(selectedFiles);
      // Reset input para permitir subir el mismo archivo de nuevo
      e.target.value = '';
    } else {
      console.log('‚ùå No hay archivos seleccionados');
    }
  };

  const addFiles = (newFiles: File[]) => {
    console.log('üì• addFiles llamado con:', newFiles.length, 'archivos');
    console.log('üîÑ isUploading:', isUploading);
    
    if (isUploading) {
      console.log('‚è∏Ô∏è Carga en progreso, cancelando');
      toast({
        title: "Espera un momento",
        description: "Ya hay una carga en progreso",
        variant: "destructive",
      });
      return;
    }

    const validFiles = newFiles.filter(file => {
      console.log('üîç Validando archivo:', file.name, 'tipo:', file.type, 'tama√±o:', file.size);
      
      const validTypes = ['application/pdf'];
      const isPdf = validTypes.includes(file.type) || file.name.toLowerCase().endsWith('.pdf');
      
      if (!isPdf) {
        console.log('‚ùå Archivo rechazado - no es PDF');
        toast({
          title: "Archivo no v√°lido",
          description: `${file.name} no es un archivo PDF`,
          variant: "destructive",
        });
        return false;
      }
      
      // Verificar tama√±o m√°ximo (10MB)
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (file.size > maxSize) {
        console.log('‚ùå Archivo rechazado - muy grande');
        toast({
          title: "Archivo muy grande",
          description: `${file.name} supera el l√≠mite de 10MB`,
          variant: "destructive",
        });
        return false;
      }
      
      console.log('‚úÖ Archivo v√°lido');
      return true;
    });

    console.log('‚úîÔ∏è Archivos v√°lidos:', validFiles.length);

    if (validFiles.length === 0) {
      console.log('‚ö†Ô∏è No hay archivos v√°lidos, saliendo');
      return;
    }

    const filesWithProgress: FileWithProgress[] = validFiles.map(file => ({
      file,
      progress: 0,
      status: 'pending',
    }));

    console.log('üíæ Actualizando estado con archivos:', filesWithProgress.length);
    setFiles(prev => {
      const newState = [...prev, ...filesWithProgress];
      console.log('üìä Nuevo estado de archivos:', newState.length);
      return newState;
    });
    
    console.log('üöÄ Iniciando carga de archivos');
    uploadFiles(filesWithProgress);
  };

  const uploadFiles = async (filesToUpload: FileWithProgress[]) => {
    setIsUploading(true);
    const token = localStorage.getItem('token');

    for (const fileItem of filesToUpload) {
      try {
        setFiles(prev => prev.map(f => 
          f.file === fileItem.file ? { ...f, status: 'uploading' } : f
        ));

        const formData = new FormData();
        formData.append('file', fileItem.file);

        const xhr = new XMLHttpRequest();

        // Timeout de 10 segundos
        xhr.timeout = 10000;

        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const progress = Math.round((e.loaded / e.total) * 100);
            setFiles(prev => prev.map(f =>
              f.file === fileItem.file ? { ...f, progress } : f
            ));
          }
        });

        xhr.addEventListener('load', () => {
          if (xhr.status === 200 || xhr.status === 201) {
            setFiles(prev => prev.map(f =>
              f.file === fileItem.file ? { ...f, status: 'success', progress: 100 } : f
            ));
            toast({
              title: "‚úÖ Archivo cargado",
              description: `${fileItem.file.name} se ha procesado exitosamente`,
            });
          } else if (xhr.status === 404) {
            // Endpoint no existe - Modo demo
            console.log('üîß Modo demo: endpoint /documents/upload no implementado');
            console.log('üìÑ Archivo simulado:', fileItem.file.name, `(${(fileItem.file.size / 1024).toFixed(2)} KB)`);
            
            // Simular progreso
            let progress = 0;
            const interval = setInterval(() => {
              progress += 10;
              setFiles(prev => prev.map(f =>
                f.file === fileItem.file ? { ...f, progress } : f
              ));
              
              if (progress >= 100) {
                clearInterval(interval);
                setFiles(prev => prev.map(f =>
                  f.file === fileItem.file ? { ...f, status: 'success', progress: 100 } : f
                ));
                toast({
                  title: "‚úÖ Modo Demostraci√≥n",
                  description: `${fileItem.file.name} validado correctamente. (Endpoint backend pendiente)`,
                });
              }
            }, 200);
          } else {
            let errorMsg = 'Error al subir archivo';
            try {
              const response = JSON.parse(xhr.responseText);
              errorMsg = response.message || response.detail || errorMsg;
            } catch (e) {
              // Si no se puede parsear, usar mensaje gen√©rico
            }
            
            setFiles(prev => prev.map(f =>
              f.file === fileItem.file 
                ? { ...f, status: 'error', error: errorMsg } 
                : f
            ));
            
            toast({
              title: "Error al cargar archivo",
              description: errorMsg,
              variant: "destructive",
            });
          }
        });

        xhr.addEventListener('error', () => {
          // Modo demo cuando no hay conexi√≥n
          console.log('üîß Modo demo: servidor no disponible');
          console.log('üìÑ Archivo validado:', fileItem.file.name);
          
          // Simular carga exitosa
          setFiles(prev => prev.map(f =>
            f.file === fileItem.file 
              ? { ...f, status: 'success', progress: 100 } 
              : f
          ));
          
          toast({
            title: "‚úÖ Modo Demostraci√≥n",
            description: `${fileItem.file.name} validado. Backend pendiente de configurar.`,
          });
        });

        xhr.addEventListener('timeout', () => {
          setFiles(prev => prev.map(f =>
            f.file === fileItem.file 
              ? { ...f, status: 'error', error: 'Tiempo de espera agotado' } 
              : f
          ));
          
          toast({
            title: "Timeout",
            description: `El servidor tard√≥ demasiado en responder`,
            variant: "destructive",
          });
        });

        xhr.open('POST', `${API_URL}/documents/upload`);
        xhr.setRequestHeader('Authorization', `Bearer ${token}`);
        xhr.send(formData);

      } catch (error) {
        setFiles(prev => prev.map(f =>
          f.file === fileItem.file 
            ? { ...f, status: 'error', error: 'Error al subir archivo' } 
            : f
        ));
        toast({
          title: "Error",
          description: `No se pudo cargar ${fileItem.file.name}`,
          variant: "destructive",
        });
      }
    }
    
    setIsUploading(false);
  };

  const removeFile = (file: File) => {
    setFiles(prev => prev.filter(f => f.file !== file));
  };

  return (
    <div className="space-y-4">
      <Card
        className={`border-2 border-dashed p-8 text-center transition-colors ${
          isDragging 
            ? 'border-primary bg-primary/5' 
            : 'border-border hover:border-primary/50'
        }`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
      >
        <Upload className="mx-auto h-12 w-12 text-muted-foreground mb-4" />
        <h3 className="text-lg font-semibold mb-2">
          Arrastra archivos PDF aqu√≠
        </h3>
        <p className="text-sm text-muted-foreground mb-4">
          o haz clic para seleccionar archivos PDF (m√°ximo 10MB por archivo)
        </p>
        <input
          id="file-upload"
          type="file"
          multiple
          accept=".pdf,application/pdf"
          onChange={handleFileInput}
          className="hidden"
          disabled={isUploading}
        />
        <Button 
          type="button" 
          variant="outline"
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('file-upload')?.click();
          }}
          disabled={isUploading}
        >
          {isUploading ? 'Cargando...' : 'Seleccionar PDFs'}
        </Button>
      </Card>

      {files.length > 0 && (
        <div className="space-y-2">
          {files.map((fileItem, index) => (
            <Card key={index} className="p-4">
              <div className="flex items-center gap-3">
                <File className="h-8 w-8 text-primary flex-shrink-0" />
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between mb-1">
                    <p className="text-sm font-medium truncate">
                      {fileItem.file.name}
                    </p>
                    <div className="flex items-center gap-2">
                      {fileItem.status === 'success' && (
                        <CheckCircle className="h-5 w-5 text-green-500" />
                      )}
                      {fileItem.status === 'error' && (
                        <AlertCircle className="h-5 w-5 text-destructive" />
                      )}
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => removeFile(fileItem.file)}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                  <p className="text-xs text-muted-foreground mb-2">
                    {(fileItem.file.size / 1024 / 1024).toFixed(2)} MB
                  </p>
                  {fileItem.status === 'uploading' && (
                    <Progress value={fileItem.progress} className="h-2" />
                  )}
                  {fileItem.status === 'error' && (
                    <p className="text-xs text-destructive">
                      {fileItem.error}
                    </p>
                  )}
                </div>
              </div>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
};
